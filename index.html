<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>StellaTouch</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --panel-bg: rgba(245, 247, 250, 0.98);
            --accent: #007bff;
            --text: #333333;
        }

        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #f0f2f5; font-family: sans-serif;
            touch-action: none; -webkit-user-select: none; user-select: none;
        }

        #setup-screen { position: fixed; inset: 0; background: white; z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; }
        .setup-box { background: #f8f9fa; padding: 30px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); width: 80%; max-width: 300px; text-align: center; }
        .setup-box input { width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 8px; box-sizing: border-box; }

        #viewport { position: fixed; inset: 0; overflow: auto; background: #ccc; display: none; }
        #canvas-container { position: relative; margin: 0 auto; background: white; box-shadow: 0 0 20px rgba(0,0,0,0.2); }
        canvas { position: absolute; top: 0; left: 0; touch-action: none; }
        #transform-overlay { position: absolute; top: 0; left: 0; pointer-events: auto; z-index: 50; display: none; }

        #header { position: fixed; top: 10px; left: 10px; right: 10px; height: 50px; background: var(--panel-bg); backdrop-filter: blur(10px); border-radius: 25px; display: flex; align-items: center; padding: 0 15px; z-index: 100; border: 1px solid rgba(0,0,0,0.1); justify-content: space-between; }
        #controls { position: fixed; bottom: 20px; left: 10px; right: 10px; background: var(--panel-bg); border-radius: 20px; padding: 15px; z-index: 100; display: flex; flex-direction: column; gap: 10px; border: 1px solid rgba(0,0,0,0.1); }
        .row { display: flex; align-items: center; gap: 8px; overflow-x: auto; }
        button, select { background: #fff; color: var(--text); border: 1px solid #ddd; padding: 8px 12px; border-radius: 10px; font-size: 13px; white-space: nowrap; }
        
        #transform-ui { position: fixed; top: 70px; left: 50%; transform: translateX(-50%); display: none; z-index: 150; background: var(--accent); color: white; padding: 10px 20px; border-radius: 30px; }
        #layer-panel { position: fixed; top: 70px; right: 10px; background: var(--panel-bg); padding: 12px; border-radius: 15px; z-index: 90; width: 200px; display: none; max-height: 50vh; overflow-y: auto; border: 1px solid rgba(0,0,0,0.1); }
        .layer-item { display: flex; flex-direction: column; gap: 6px; padding: 10px; margin-bottom: 8px; background: #fff; border-radius: 8px; font-size: 12px; }
        .layer-active { border: 2px solid var(--accent); }
    </style>
</head>
<body>

<div id="setup-screen">
    <h1 style="color: var(--accent);">StellaTouch</h1>
    <div class="setup-box">
        <input type="number" id="inputW" placeholder="幅 (px)">
        <input type="number" id="inputH" placeholder="高さ (px)">
        <button onclick="initApp()" style="width: 100%; padding: 12px; background: var(--accent); color: white; border: none; border-radius: 10px;">開始</button>
        <button onclick="setScreenSize()" style="margin-top: 10px; background: none; border: none; font-size: 12px;">端末サイズを自動取得</button>
    </div>
</div>

<div id="viewport">
    <div id="canvas-container">
        <canvas id="transform-overlay"></canvas>
    </div>
</div>

<div id="transform-ui">
    変形中: 枠内で移動 / 右下で拡大 / 上の●で回転
    <button onclick="commitTransform()" style="margin-left:10px; border-radius:15px; border:none; padding:5px 15px;">確定</button>
</div>

<div id="header">
    <div style="display:flex; gap:5px;"><button onclick="undo()">⬅️</button><button onclick="redo()">➡️</button></div>
    <div style="font-weight:bold; color:var(--accent);">StellaTouch</div>
    <div style="display:flex; gap:5px;"><button onclick="toggleLayers()">層</button><button onclick="saveImageWithDate()" style="background:var(--accent); color:white;">保存</button></div>
</div>

<div id="layer-panel"><div id="layerList"></div><button onclick="addLayer()" style="width:100%; margin-top:5px; background:var(--accent); color:white;">+ 新規レイヤー</button></div>

<div id="controls">
    <div class="row">
        <input type="color" id="picker" value="#007bff">
        <select id="tool">
            <option value="brush">ブラシ</option>
            <option value="eraser">消しゴム</option>
            <option value="glow">発光</option>
            <option value="fill">塗りつぶし</option>
            <option value="stamp">スタンプ</option>
        </select>
        <button onclick="triggerImageLayer()">＋画像レイヤー</button>
        <input type="file" id="imgLayerInput" hidden accept="image/*" onchange="handleImageLayer(this)">
    </div>
    <div class="row">サイズ<input type="range" id="size" min="1" max="500" value="40" style="flex-grow:1;"></div>
</div>

<script>
    let layers = [];
    let curIdx = -1;
    let drawing = false;
    let canvasW, canvasH;
    let history = [];
    let historyStep = -1;

    // 変形用
    let isTransforming = false;
    let tfImg = null, tfX = 0, tfY = 0, tfW = 200, tfH = 200, tfAngle = 0;
    let tfMode = null; 
    let startX, startY, startW, startH, startAngle, startDist, startMouseAngle;

    const ov = document.getElementById('transform-overlay');
    const octx = ov.getContext('2d');

    function setScreenSize() { document.getElementById('inputW').value = window.innerWidth; document.getElementById('inputH').value = window.innerHeight; }

    function initApp() {
        canvasW = parseInt(document.getElementById('inputW').value) || 800;
        canvasH = parseInt(document.getElementById('inputH').value) || 1200;
        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('viewport').style.display = 'block';
        const container = document.getElementById('canvas-container');
        container.style.width = canvasW + 'px'; container.style.height = canvasH + 'px';
        ov.width = canvasW; ov.height = canvasH;
        addLayer(); addLayer();
    }

    function triggerImageLayer() { document.getElementById('imgLayerInput').click(); }

    function handleImageLayer(input) {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    isTransforming = true;
                    tfImg = img;
                    tfW = canvasW * 0.5;
                    tfH = tfW * (img.height / img.width);
                    tfX = (canvasW - tfW) / 2;
                    tfY = (canvasH - tfH) / 2;
                    tfAngle = 0;
                    ov.style.display = 'block';
                    document.getElementById('transform-ui').style.display = 'block';
                    drawTransform();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(input.files[0]);
        }
        input.value = "";
    }

    function drawTransform() {
        octx.clearRect(0, 0, canvasW, canvasH);
        octx.save();
        octx.translate(tfX + tfW / 2, tfY + tfH / 2);
        octx.rotate(tfAngle);
        octx.globalAlpha = 0.7;
        octx.drawImage(tfImg, -tfW / 2, -tfH / 2, tfW, tfH);
        octx.strokeStyle = '#007bff'; octx.lineWidth = 3;
        octx.strokeRect(-tfW / 2, -tfH / 2, tfW, tfH);
        octx.fillStyle = 'white';
        octx.fillRect(tfW/2 - 15, tfH/2 - 15, 30, 30); 
        octx.beginPath(); octx.arc(0, -tfH/2 - 40, 15, 0, Math.PI*2); octx.fill(); octx.stroke(); 
        octx.restore();
    }

    ov.addEventListener('pointerdown', (e) => {
        if (!isTransforming) return;
        const rect = ov.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (canvasW / rect.width);
        const my = (e.clientY - rect.top) * (canvasH / rect.height);
        const cx = tfX + tfW / 2; const cy = tfY + tfH / 2;
        const dx = mx - cx; const dy = my - cy;
        const localX = dx * Math.cos(-tfAngle) - dy * Math.sin(-tfAngle);
        const localY = dx * Math.sin(-tfAngle) + dy * Math.cos(-tfAngle);

        if (Math.sqrt(dx*dx + (dy + tfH/2 + 40)*(dy + tfH/2 + 40)) < 30) {
            tfMode = 'rotate';
            startMouseAngle = Math.atan2(dy, dx);
            startAngle = tfAngle;
        } else if (Math.abs(localX - tfW/2) < 30 && Math.abs(localY - tfH/2) < 30) {
            tfMode = 'scale';
            startDist = Math.sqrt(dx*dx + dy*dy);
            startW = tfW; startH = tfH;
        } else if (Math.abs(localX) < tfW/2 && Math.abs(localY) < tfH/2) {
            tfMode = 'move';
            startX = mx - tfX; startY = my - tfY;
        }
    });

    window.addEventListener('pointermove', (e) => {
        if (!isTransforming || !tfMode) return;
        const rect = ov.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (canvasW / rect.width);
        const my = (e.clientY - rect.top) * (canvasH / rect.height);
        const cx = tfX + tfW / 2; const cy = tfY + tfH / 2;

        if (tfMode === 'move') {
            tfX = mx - startX; tfY = my - startY;
        } else if (tfMode === 'scale') {
            const newDist = Math.sqrt((mx - cx)**2 + (my - cy)**2);
            const ratio = newDist / startDist;
            tfW = startW * ratio; tfH = startH * ratio;
            tfX = cx - tfW / 2; tfY = cy - tfH / 2;
        } else if (tfMode === 'rotate') {
            const currentMouseAngle = Math.atan2(my - cy, mx - cx);
            tfAngle = startAngle + (currentMouseAngle - startMouseAngle);
        }
        drawTransform();
    });

    window.addEventListener('pointerup', () => { tfMode = null; });

    function commitTransform() {
        addLayer(null, "画像レイヤー");
        const ctx = layers[curIdx].ctx;
        ctx.save();
        ctx.translate(tfX + tfW/2, tfY + tfH/2);
        ctx.rotate(tfAngle);
        ctx.drawImage(tfImg, -tfW/2, -tfH/2, tfW, tfH);
        ctx.restore();
        isTransforming = false;
        ov.style.display = 'none';
        document.getElementById('transform-ui').style.display = 'none';
        saveState();
    }

    // --- 描画コア ---
    function addLayer(dummy, name) {
        const container = document.getElementById('canvas-container');
        const canvas = document.createElement('canvas');
        canvas.width = canvasW; canvas.height = canvasH;
        const ctx = canvas.getContext('2d', {willReadFrequently:true});
        if (layers.length === 0) { ctx.fillStyle = "#ffffff"; ctx.fillRect(0,0,canvasW,canvasH); }
        const obj = { canvas, ctx, opacity: 1, name: name || `レイヤー ${layers.length+1}` };
        layers.push(obj);
        container.insertBefore(canvas, ov);
        canvas.addEventListener('pointerdown', startDrawing);
        canvas.addEventListener('pointermove', moveDrawing);
        curIdx = layers.length - 1;
        renderLayerUI();
    }

    let lastX, lastY;
    function startDrawing(e) {
        if (isTransforming) return;
        const rect = this.getBoundingClientRect();
        lastX = (e.clientX - rect.left) * (canvasW / rect.width);
        lastY = (e.clientY - rect.top) * (canvasH / rect.height);
        const tool = document.getElementById('tool').value;
        if (tool === 'fill') { floodFill(Math.round(lastX), Math.round(lastY)); saveState(); }
        else if (tool === 'stamp') { drawStamp(lastX, lastY); saveState(); }
        else { drawing = true; }
    }

    function moveDrawing(e) {
        if (!drawing) return;
        const rect = this.getBoundingClientRect();
        const mx = (e.clientX - rect.left) * (canvasW / rect.width);
        const my = (e.clientY - rect.top) * (canvasH / rect.height);
        const ctx = layers[curIdx].ctx;
        const tool = document.getElementById('tool').value;
        const color = document.getElementById('picker').value;
        const baseSize = document.getElementById('size').value;

        // 筆圧感知の適用 (pressureが取得できない場合は 0.5)
        const pressure = e.pressure || 0.5;
        const dynamicSize = baseSize * (0.1 + pressure * 0.9);

        ctx.save();
        if (tool === 'eraser') {
            ctx.globalCompositeOperation = 'destination-out';
        } else {
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = color;
            if (tool === 'glow') {
                ctx.shadowBlur = dynamicSize / 2;
                ctx.shadowColor = color;
            }
        }

        ctx.lineWidth = dynamicSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(mx, my);
        ctx.stroke();
        ctx.restore();

        lastX = mx; lastY = my;
    }

    window.addEventListener('pointerup', () => { if(drawing) { drawing = false; saveState(); } });

    // --- その他機能 ---
    function renderLayerUI() {
        const list = document.getElementById('layerList'); list.innerHTML = '';
        for (let i = layers.length-1; i >= 0; i--) {
            const d = document.createElement('div'); d.className = `layer-item ${i===curIdx?'layer-active':''}`;
            d.innerHTML = `<div style="display:flex; justify-content:space-between;"><b>${layers[i].name}</b> 
            <div><button onclick="curIdx=${i};renderLayerUI()">選</button>
            <button onclick="deleteLayer(${i})" style="color:red">×</button></div></div>
            <input type="range" min="0" max="1" step="0.01" value="${layers[i].opacity}" oninput="layers[${i}].opacity=this.value;layers[${i}].canvas.style.opacity=this.value">`;
            list.appendChild(d);
        }
    }

    function deleteLayer(idx) {
        if (layers.length <= 1) return;
        document.getElementById('canvas-container').removeChild(layers[idx].canvas);
        layers.splice(idx, 1);
        curIdx = Math.min(curIdx, layers.length - 1);
        renderLayerUI();
        saveState();
    }

    function saveState() { 
        historyStep++; history.splice(historyStep);
        history.push(layers.map(l => ({ data: l.canvas.toDataURL(), opacity: l.opacity, name: l.name })));
    }

    function undo() { if(historyStep>0) { historyStep--; load(history[historyStep]); } }
    function redo() { if(historyStep<history.length-1) { historyStep++; load(history[historyStep]); } }
    function load(st) { st.forEach((s,i) => { if(!layers[i]) return; const img=new Image(); img.onload=()=>{layers[i].ctx.clearRect(0,0,canvasW,canvasH);layers[i].ctx.drawImage(img,0,0);}; img.src=s.data; }); }
    function toggleLayers() { const p=document.getElementById('layer-panel'); p.style.display=p.style.display==='block'?'none':'block'; }
    function drawStamp(x,y) { const ctx=layers[curIdx].ctx; ctx.font=`${document.getElementById('size').value}px serif`; ctx.fillText("⭐",x,y); }

    function saveImageWithDate() { 
        const out=document.createElement('canvas'); out.width=canvasW; out.height=canvasH; const octx=out.getContext('2d');
        layers.forEach(l=>{octx.globalAlpha = l.opacity; octx.drawImage(l.canvas,0,0);});
        const n=new Date(); const ds=n.getFullYear()+String(n.getMonth()+1).padStart(2,'0')+String(n.getDate()).padStart(2,'0');
        const link=document.createElement('a'); link.download=`StellaTouch_${ds}.png`; link.href=out.toDataURL(); link.click();
    }

    function floodFill(x,y) { 
        const ctx=layers[curIdx].ctx; const id=ctx.getImageData(0,0,canvasW,canvasH); const d=id.data; const p=(y*canvasW+x)*4;
        const tr=d[p], tg=d[p+1], tb=d[p+2], ta=d[p+3];
        const fc=document.getElementById('picker').value;
        const f={r:parseInt(fc.slice(1,3),16), g:parseInt(fc.slice(3,5),16), b:parseInt(fc.slice(5,7),16)};
        if(tr===f.r&&tg===f.g&&tb===f.b&&ta===255) return;
        const q=[[x,y]];
        while(q.length){
            const [cx,cy]=q.pop(); const cp=(cy*canvasW+cx)*4;
            if(cx>=0&&cx<canvasW&&cy>=0&&cy<canvasH&&d[cp]===tr&&d[cp+1]===tg&&d[cp+2]===tb&&d[cp+3]===ta){
                d[cp]=f.r; d[cp+1]=f.g; d[cp+2]=f.b; d[cp+3]=255;
                q.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
            }
        } ctx.putImageData(id,0,0);
    }
</script>
</body>
</html>
